


## Part 1 Report 

In this project we adjusted our shared memory allocator that used a semaphore locking mechanism to using mutex in the pthreads library. I did this by changing the semephore initialization to `pthread_mutex_t mLock = PTHREAD_MUTEX_INITIALIZER;`. Due to the heap being shared across all processes, each operation acting on the free memory list had to be protected by a semaphore which itself was housed in shared memory. By changing to a thread based solution, we eliminated the need to allocate explicitly shared memory because of threads sharing the same address space which reduces overhead and clears out a fair amount of code from our file as well. The overall implementation was rather straight forward. I changed `umum()` to use regular malloc from umalloc and ufree *if `use_multithread` flag was raised*. Then at the start of the function initialize an array for threads, their arguments and their hash results, as well as initializing the threads arguments. In place of forking a process we simply create a new thread, passing in the address of the indexed space, the worker thread and its arguments. After all threads a threa has run, we wait for all threads to complete using `pthread_join` for each block we have and finally accumulate all our hash results to print the final resulting hash. As previously mentioned, one of the primary benefits of this solution is that threads share an address space, but other than that the lower memory overhead resulting from not creating child processes which also requires heavy context switching improves performance as well.
